---
layout: post
title: "一个java内存泄漏排查案例"
date: 2013-07-25 21:33
comments: true
categories: [java技术]
---


纪录一下定位问题的整个过程。  

初步的现象是业务系统消费MQ中消息速度很慢，积压了200多万条消息，通过jstat观察到业务系统fullgc频繁：  
![](/static/gc.png)

接着要知道是哪些对象占用了大量内存，于是用jmap查看存活的对象情况，可以看出HashTable中的元素有5000多万，占用内存大约1.5G的样子：  
![](/static/jmap.png)

接下来自然要看看是什么代码往HashTable里疯狂的put数据，于是用神器btrace跟踪Hashtable.put调用的堆栈。
首先写btrace脚本TracingHashTable.java：

	import com.sun.btrace.annotations.*;
	import static com.sun.btrace.BTraceUtils.*;

	@BTrace
	public class TracingHashTable {
    		/* put your code here */
    		/*指明要查看的方法，类*/
      		@OnMethod(
        		clazz="java.util.Hashtable",
        		method="put",
        		location=@Location(Kind.RETURN) )

    		public static void traceExecute(@Self java.util.Hashtable object){
            		println("调用堆栈！！");
             		jstack();
    		}
	}

然后运行：
bin/btrace -cp build 4947 TracingHashTable.java  
看到有大量类似下图的调用堆栈  
![](/static/btrace.png)

可以看出是在消费消息时入库的代码造成的，业务方法调用ibatis再到mysql jdbc驱动执行statement时put了大量的属性到HashTable中。

通过以上排查已基本定位了问题，可以使用prepareStatement进行改造.
